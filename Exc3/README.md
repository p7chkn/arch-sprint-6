## Переход на event-driven архитектуру

### Схемы
- [текущая схема](InsureTech_C4_сontainer-diagram-as-is.drawio.xml)
- [схема решения](InsureTech_C4_сontainer-diagram-to-be.drawio.xml)

### Анализ текущей ситуации
1. Подход с синхронным обращением к сервису _ins-product-aggregator_ является на масштабируемым
так как, высока вероятность появления новых сервисов, которым будет нужна информация оттуда
и придется его масштабировать полностью (если выбрать асинхронное взаимодействие, то масштабировать
в таком случае нужно будет только брокер сообщений, что проще, чем весь сервис). Это утверждение
справедливо так же и для обращения от _ins-comp-settlement_ к _core-app_.
2. Есть проблема в сервисе _ins-product-aggregator_ - он синхронно обращается во внешнюю систему, в этом
есть ряд проблем: при росте нагрузке - рост нагрузки на внешний API, есть вероятность упереться в rate-limit,
так же при проблемах с внешней сетью или внешним сервисом - у нас нет никаких данных, которые мы можем отдать.
3. При увеличении объемов информации, запросы к REST API будут вынуждены получать еще больше данных
чем сейчас, а уже на данный момент есть проблемы с надежностью, при увеличении оборота данных это
будет лишь усугубляться.
4. При возникающих ошибках, не так просто настроить fallback, который будет эффективно устранять
пробелы в данных.

### Решение текущих проблем:
1. Мы храним данные о продуктах и услугах теперь в базе данных, а изменения доступных продуктах
_ins-product-aggregator_ публикует в брокер сообщений, используя паттерн Transactional Outbox, 
так же помечая сообщения уникальным идентификатором, чтобы можно было их определить однозначно.
2. Сервисы _ins-comp-settlement_ к _core-app_, которым эти данные нужны - подписываются на соответствующий
топик в брокере сообщений и получают актуальную информацию с меньшей задержкой, чем раньше.
3. Сервис _core-app_ публикует сообщения об оформленных за день страховках так же в брокер сообщений с 
использованием паттерна Transaction Outbox. (При этом сервис _ins-comp-settlement_, если у него нет 
необходимости в актуальных данных и они нужны только ночью, может продолжать выполнять свою задачу ночью,
только теперь он будет не обращаться по API, а вычитывать сообщения из очереди).